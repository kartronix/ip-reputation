"""
IP Reputation + WHOIS + Historical DNS Viewer
------------------------------------------------
A single-file Streamlit app that combines:
- IP/Domain input (auto-resolves domain -> IP)
- IP geolocation (ip-api.com)
- WHOIS (ipwhois + python-whois)
- AbuseIPDB reputation (optional API key)
- VirusTotal IP report (optional API key)
- Historical DNS + Reverse IP (SecurityTrails optional API key; crt.sh fallback)
- DNS & WHOIS timelines
- Export to JSON/CSV
- Diagnostics for API keys

How to run:
  pip install -r requirements.txt  # see REQUIREMENTS block below
  streamlit run app.py

Secrets/Keys:
  Use Streamlit Secrets (recommended) by creating .streamlit/secrets.toml:
    ABUSEIPDB_API_KEY = "..."
    VT_API_KEY = "..."
    SECURITYTRAILS_API_KEY = "..."
  Or paste keys in the sidebar at runtime.

Author: Generated by ChatGPT
License: MIT
"""

from __future__ import annotations

import re
import ipaddress
import json
import socket
import time
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple

import requests
import pandas as pd
import streamlit as st

# Optional deps: handle import errors gracefully
try:
    from ipwhois import IPWhois
except Exception:
    IPWhois = None  # type: ignore

try:
    import whois as pywhois  # python-whois
except Exception:
    pywhois = None  # type: ignore

# ----------------------------
# Streamlit Page Config
# ----------------------------
st.set_page_config(
    page_title="IP Reputation + WHOIS + DNS History",
    page_icon="🛰️",
    layout="wide",
)

# ----------------------------
# Utilities
# ----------------------------
IP_RE = re.compile(r"^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$")


def is_ip(value: str) -> bool:
    try:
        ipaddress.ip_address(value)
        return True
    except Exception:
        return False


def resolve_domain(domain: str) -> Optional[str]:
    try:
        return socket.gethostbyname(domain)
    except Exception:
        return None


# Cache helper
@st.cache_data(show_spinner=False)
def cached_get(url: str, headers: Optional[Dict[str, str]] = None, params: Optional[Dict[str, Any]] = None, timeout: int = 15) -> Tuple[int, Dict[str, Any]]:
    resp = requests.get(url, headers=headers or {}, params=params or {}, timeout=timeout)
    try:
        data = resp.json()
    except Exception:
        try:
            data = {"text": resp.text}
        except Exception:
            data = {}
    return resp.status_code, data


# ----------------------------
# Data Source Functions
# ----------------------------
@st.cache_data(show_spinner=False)
def fetch_ip_geo(ip: str) -> Dict[str, Any]:
    """ip-api.com geolocation (no key, fair-use)."""
    status, data = cached_get(f"http://ip-api.com/json/{ip}", params={"fields": "66846719"})
    return {"status": status, "source": "ip-api.com", "data": data}


@st.cache_data(show_spinner=False)
def fetch_abuseipdb(ip: str, api_key: Optional[str]) -> Dict[str, Any]:
    if not api_key:
        return {"status": 0, "source": "AbuseIPDB", "error": "No API key"}
    headers = {"Key": api_key, "Accept": "application/json"}
    status, data = cached_get("https://api.abuseipdb.com/api/v2/check", headers=headers, params={"ipAddress": ip, "maxAgeInDays": 365})
    return {"status": status, "source": "AbuseIPDB", "data": data}


@st.cache_data(show_spinner=False)
def fetch_virustotal_ip(ip: str, api_key: Optional[str]) -> Dict[str, Any]:
    if not api_key:
        return {"status": 0, "source": "VirusTotal", "error": "No API key"}
    headers = {"x-apikey": api_key}
    status, data = cached_get(f"https://www.virustotal.com/api/v3/ip_addresses/{ip}", headers=headers)
    return {"status": status, "source": "VirusTotal", "data": data}


@st.cache_data(show_spinner=False)
def fetch_securitytrails_dns_history(domain: str, api_key: Optional[str]) -> Dict[str, Any]:
    """Historical DNS for a domain via SecurityTrails."""
    if not api_key:
        return {"status": 0, "source": "SecurityTrails", "error": "No API key"}
    headers = {"APIKEY": api_key}
    status, data = cached_get(f"https://api.securitytrails.com/v1/history/{domain}/dns/a", headers=headers)
    return {"status": status, "source": "SecurityTrails", "data": data}


@st.cache_data(show_spinner=False)
def fetch_securitytrails_reverse_ip(ip: str, api_key: Optional[str]) -> Dict[str, Any]:
    if not api_key:
        return {"status": 0, "source": "SecurityTrails", "error": "No API key"}
    headers = {"APIKEY": api_key}
    status, data = cached_get(f"https://api.securitytrails.com/v1/ips/nearby/{ip}", headers=headers)
    # Note: /ips/nearby gives context; for associated domains use /ips/list?ip= or /domain/{}/subdomains; paid tiers vary.
    return {"status": status, "source": "SecurityTrails", "data": data}


@st.cache_data(show_spinner=False)
def fetch_crtsh_domains(query_domain: str) -> List[str]:
    """Query crt.sh for certificates matching the domain to infer related domains/subdomains."""
    q = f"%25.{query_domain}" if not query_domain.startswith("%25") else query_domain
    url = "https://crt.sh/"  # supports JSON output
    try:
        status, data = cached_get(url, params={"q": q, "output": "json"})
        if status == 200 and isinstance(data, list):
            names = set()
            for item in data:
                name_value = item.get("name_value")
                if name_value:
                    for n in str(name_value).split("\n"):
                        n = n.strip().lower()
                        if n and "*" not in n:
                            names.add(n)
            return sorted(names)
    except Exception:
        pass
    return []


def whois_ip(ip: str) -> Dict[str, Any]:
    if IPWhois is None:
        return {"error": "ipwhois not installed"}
    try:
        obj = IPWhois(ip)
        res = obj.lookup_rdap(asn_methods=["whois", "http"])
        return res
    except Exception as e:
        return {"error": str(e)}


def whois_domain(domain: str) -> Dict[str, Any]:
    if pywhois is None:
        return {"error": "python-whois not installed"}
    try:
        w = pywhois.whois(domain)
        # Convert to serializable dict
        out = {}
        for k, v in w.__dict__.items():
            if k.startswith("_"):
                continue
            if isinstance(v, (datetime,)):
                out[k] = v.isoformat()
            elif isinstance(v, (list, tuple)):
                out[k] = [x.isoformat() if isinstance(x, datetime) else str(x) for x in v]
            else:
                try:
                    json.dumps(v)
                    out[k] = v
                except Exception:
                    out[k] = str(v)
        return out
    except Exception as e:
        return {"error": str(e)}


# ----------------------------
# Visualization Helpers
# ----------------------------

def draw_dns_timeline(a_history: Dict[str, Any]):
    try:
        records = []
        # SecurityTrails format: { records: [ { values: [{ip:"1.2.3.4"}], first_seen:"...", last_seen:"..." }, ...] }
        for rec in a_history.get("data", {}).get("records", []):
            first_seen = rec.get("first_seen")
            last_seen = rec.get("last_seen")
            for val in rec.get("values", []):
                ip = val.get("ip") or val.get("value")
                if ip:
                    records.append({"ip": ip, "first_seen": first_seen, "last_seen": last_seen})
        if not records:
            st.info("No A record history available to plot.")
            return
        df = pd.DataFrame(records)
        # Expand to one row per (ip, date) range edges for simple plotting
        df_plot = pd.melt(
            df,
            id_vars=["ip"],
            value_vars=["first_seen", "last_seen"],
            var_name="edge",
            value_name="date",
        )
        df_plot["date"] = pd.to_datetime(df_plot["date"], errors="coerce")
        df_plot = df_plot.dropna(subset=["date"]) 
        st.altair_chart(
            __import__("altair").Chart(df_plot).mark_circle().encode(
                x="date:T",
                y="ip:N",
                tooltip=["ip", "edge", "date"],
            ).properties(height=300),
            use_container_width=True,
        )
    except Exception as e:
        st.warning(f"Timeline plot failed: {e}")


def draw_relation_graph(domains: List[str], ip: Optional[str]):
    """Simple relation table; for graph you can later swap to PyVis/NetworkX."""
    if not domains:
        st.info("No related domains to visualize.")
        return
    df = pd.DataFrame({"domain": domains})
    if ip:
        df["ip"] = ip
    st.dataframe(df, use_container_width=True)


# ----------------------------
# Export Helpers
# ----------------------------

def json_download_button(obj: Any, label: str, file_name: str):
    st.download_button(
        label=label,
        data=json.dumps(obj, indent=2, default=str).encode("utf-8"),
        file_name=file_name,
        mime="application/json",
    )


def csv_download_button(df: pd.DataFrame, label: str, file_name: str):
    st.download_button(
        label=label,
        data=df.to_csv(index=False).encode("utf-8"),
        file_name=file_name,
        mime="text/csv",
    )


# ----------------------------
# Sidebar: Inputs & Diagnostics
# ----------------------------
with st.sidebar:
    st.title("🔧 Settings")
    st.caption("Paste API keys here or configure in `.streamlit/secrets.toml`.")

    abuse_key = st.text_input("AbuseIPDB API Key", type="password", value=st.secrets.get("ABUSEIPDB_API_KEY", ""))
    vt_key = st.text_input("VirusTotal API Key", type="password", value=st.secrets.get("VT_API_KEY", ""))
    st_key = st.text_input("SecurityTrails API Key", type="password", value=st.secrets.get("SECURITYTRAILS_API_KEY", ""))

    st.markdown("---")
    st.subheader("🩺 Diagnostics")
    diag = {
        "AbuseIPDB key": bool(abuse_key),
        "VirusTotal key": bool(vt_key),
        "SecurityTrails key": bool(st_key),
        "ipwhois installed": IPWhois is not None,
        "python-whois installed": pywhois is not None,
    }
    st.json(diag)

# ----------------------------
# Main App
# ----------------------------
st.title("🛰️ IP Reputation + WHOIS + Historical DNS Viewer")
st.write("Enter an IP address or a domain. The app will enrich with WHOIS, reputation, and DNS history.")

col_inp, col_opts = st.columns([2, 1])
with col_inp:
    user_input = st.text_input("IP or Domain", placeholder="e.g., 8.8.8.8 or example.com").strip()
with col_opts:
    auto_resolve = st.checkbox("Auto-resolve domain → IP", value=True)

if user_input:
    target_is_ip = is_ip(user_input)
    domain = None
    ip = user_input if target_is_ip else None

    if not target_is_ip:
        domain = user_input.lower()
        if auto_resolve:
            with st.spinner("Resolving domain to IP..."):
                ip = resolve_domain(domain)
                if not ip:
                    st.warning("Could not resolve domain to IP.")

    # Layout
    tab_summary, tab_whois, tab_dns, tab_rep, tab_related, tab_raw = st.tabs([
        "Summary", "WHOIS", "DNS History", "Reputation", "Related Domains", "Raw JSON",
    ])

    # ----------------------------
    # Fetch Data
    # ----------------------------
    geo = fetch_ip_geo(ip) if ip else {"error": "No IP"}
    abuse = fetch_abuseipdb(ip, abuse_key) if ip else {"error": "No IP"}
    vt = fetch_virustotal_ip(ip, vt_key) if ip else {"error": "No IP"}

    # WHOIS
    whois_ip_data = whois_ip(ip) if ip else {"note": "No IP to WHOIS"}
    whois_domain_data = whois_domain(domain) if domain else {"note": "No domain to WHOIS"}

    # DNS History & Related
    dns_hist = fetch_securitytrails_dns_history(domain, st_key) if domain else {"note": "No domain"}
    related_domains = []
    if domain:
        related_domains = fetch_crtsh_domains(domain)

    # ----------------------------
    # Summary Tab
    # ----------------------------
    with tab_summary:
        st.subheader("Overview")
        meta_cols = st.columns(4)
        meta_cols[0].metric("Input", user_input)
        meta_cols[1].metric("Type", "IP" if target_is_ip else "Domain")
        meta_cols[2].metric("Resolved IP", ip or "—")
        asn = whois_ip_data.get("asn") if isinstance(whois_ip_data, dict) else None
        meta_cols[3].metric("ASN", str(asn or "—"))

        st.markdown("### Geolocation (ip-api.com)")
        st.json(geo.get("data") if isinstance(geo, dict) else geo)

        if abuse.get("data") and isinstance(abuse["data"], dict) and abuse["data"].get("data"):
            score = abuse["data"]["data"].get("abuseConfidenceScore", "—")
            total_reports = abuse["data"]["data"].get("totalReports", "—")
            st.markdown(f"**AbuseIPDB**: Confidence Score **{score}**, Total Reports **{total_reports}** (last 365d)")
        else:
            st.caption("AbuseIPDB: no data or no key.")

    # ----------------------------
    # WHOIS Tab
    # ----------------------------
    with tab_whois:
        st.subheader("WHOIS")
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**IP RDAP / WHOIS**")
            st.json(whois_ip_data)
        with col2:
            st.markdown("**Domain WHOIS**")
            st.json(whois_domain_data)

    # ----------------------------
    # DNS History Tab
    # ----------------------------
    with tab_dns:
        st.subheader("Historical DNS (A records)")
        if dns_hist.get("data"):
            st.json(dns_hist.get("data"))
            st.markdown("#### Timeline")
            draw_dns_timeline(dns_hist)
        else:
            st.info("No SecurityTrails data (missing key or domain not provided).")

    # ----------------------------
    # Reputation Tab
    # ----------------------------
    with tab_rep:
        st.subheader("Reputation")
        colA, colB = st.columns(2)
        with colA:
            st.markdown("**AbuseIPDB**")
            st.json(abuse)
        with colB:
            st.markdown("**VirusTotal (IP)**")
            st.json(vt)

    # ----------------------------
    # Related Domains Tab
    # ----------------------------
    with tab_related:
        st.subheader("Related Domains (crt.sh)")
        if related_domains:
            df_rel = pd.DataFrame({"domain": related_domains})
            st.dataframe(df_rel, use_container_width=True)
            csv_download_button(df_rel, "Download related domains CSV", f"related_{(domain or ip or 'target').replace('.', '_')}.csv")
        else:
            st.info("No related domains found or crt.sh unavailable.")
        st.caption("Tip: Add SecurityTrails for richer reverse-IP & subdomain history.")

    # ----------------------------
    # Raw JSON + Export
    # ----------------------------
    with tab_raw:
        st.subheader("Raw JSON Export")
        bundle = {
            "input": user_input,
            "resolved_ip": ip,
            "geo": geo,
            "abuseipdb": abuse,
            "virustotal": vt,
            "whois_ip": whois_ip_data,
            "whois_domain": whois_domain_data,
            "dns_history": dns_hist,
            "related_domains": related_domains,
            "generated_at": datetime.utcnow().isoformat() + "Z",
        }
        st.json(bundle)
        json_download_button(bundle, "Download JSON", f"enriched_{(domain or ip or 'target').replace('.', '_')}.json")

# ----------------------------
# Footer
# ----------------------------
st.markdown("---")
st.caption(
    "This tool aggregates public OSINT sources. Respect API terms, rate limits, and legal/ethical boundaries."
)

# ----------------------------
# REQUIREMENTS (for your reference)
# ----------------------------
# Create a requirements.txt with:
# streamlit
# requests
# ipwhois
# python-whois
# pandas
# altair
